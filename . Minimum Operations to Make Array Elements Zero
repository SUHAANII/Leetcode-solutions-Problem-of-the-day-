question: You are given a 2D array queries, where queries[i] is of the form [l, r]. Each queries[i] defines an array of integers nums consisting of elements ranging from l to r, both inclusive.

In one operation, you can:

Select two integers a and b from the array.
Replace them with floor(a / 4) and floor(b / 4).
Your task is to determine the minimum number of operations required to reduce all elements of the array to zero for each query. Return the sum of the results for all queries.

code:

// Array to store precomputed values of expSum for logarithmic indices
long long expSum4[18] = {0};

class Solution {
public:
    // Function to compute the exponential sum for a given unsigned integer x
    static long long expSum(unsigned x) {
        // Base case: if x is 0, return 0
        if (x == 0) return 0;

        // Calculate log4, which is the highest power of 4 that fits in x
        int log4 = (31 - __builtin_clz(x)) / 2; // Count leading zeros to find the log base 4
        int r = x - (1 << (2 * log4)); // Calculate the remainder after removing the highest power of 4

        // Return the precomputed sum for log4 and add the contribution from r
        return expSum4[log4] + r * (log4 + 1LL);
    }

    // Function to precompute values of expSum4[]
    static void precompute() {
        // If expSum4[0] is already computed, return early
        if (expSum4[0] == 1) return;

        expSum4[0] = 1; // Initialize the first value
        // Precompute values for expSum4[] up to index 17
        for (int i = 1; i < 18; i++) {
            expSum4[i] = expSum4[i - 1] + 3LL * i * (1LL << (2 * (i - 1))) + 1;
            // Debug output (commented out): Print the current index and its computed value
            // cout << i << "->" << expSum4[i] << ", ";
        }
    }

    // Function to compute the minimum operations based on the queries
    static long long minOperations(vector<vector<int>>& queries) {
        precompute(); // Ensure that expSum4[] is computed before processing queries
        long long op = 0; // Variable to accumulate the total operations

        // Iterate through each query
        for (auto& q : queries) {
            int l = q[0] - 1; // Left index (adjusting for 0-based index)
            int r = q[1];     // Right index

            // Calculate the operations needed for the range and accumulate
            op += (expSum(r) - expSum(l) + 1) / 2; // Ceiling of (expSum(r) - expSum(l)) / 2
        }
        return op; // Return the total operations
    }
};
