question: You have two soups, A and B, each starting with n mL. On every turn, one of the following four serving operations is chosen at random, each with probability 0.25 independent of all previous turns:

pour 100 mL from type A and 0 mL from type B
pour 75 mL from type A and 25 mL from type B
pour 50 mL from type A and 50 mL from type B
pour 25 mL from type A and 75 mL from type B
Note:

There is no operation that pours 0 mL from A and 100 mL from B.
The amounts from A and B are poured simultaneously during the turn.
If an operation asks you to pour more than you have left of a soup, pour all that remains of that soup.
The process stops immediately after any turn in which one of the soups is used up.

Return the probability that A is used up before B, plus half the probability that both soups are used up in the same turn. Answers within 10-5 of the actual answer will be accepted.

code:

// Declare a 2D array for memoization to store results of subproblems
double dp[201][201];

class Solution {
public:
    // Recursive function using Depth-First Search (DFS) to calculate probabilities
    double dfs(int A, int B) {
        // If A is depleted and B is still positive, player B wins
        if (A <= 0 && B > 0) return 1;
        // If both A and B are depleted, it's a tie
        if (A <= 0 && B <= 0) return 0.5;
        // If A is still positive but B is depleted, player A wins
        if (A > 0 && B <= 0) return 0;
        
        // If we have already computed this state, return the stored result
        if (dp[A][B] != -1) return dp[A][B];
        
        // Calculate the probability of winning by taking one of the four possible actions
        double ans = 0.25 * (dfs(A - 4, B) +  // Serve 4 ounces from A
                             dfs(A - 3, B - 1) +  // Serve 3 ounces from A and 1 from B
                             dfs(A - 2, B - 2) +  // Serve 2 ounces from A and 2 from B
                             dfs(A - 1, B - 3));  // Serve 1 ounce from A and 3 from B
        
        // Store the computed result in the memoization table and return it
        return dp[A][B] = ans;
    }

    // Main function to calculate the soup servings probability
    double soupServings(int n) {
        // If n is greater than 5000, return 1 (probability of A winning approaches 1)
        if (n > 5000) return 1;
        
        // Initialize the memoization table with -1 to indicate uncomputed states
        fill(&dp[0][0], &dp[0][0] + 201 * 201, -1);
        
        // Normalize n by dividing by 25 and rounding up
        int N = ceil(n / 25.0);
        
        // Call the DFS function starting with N ounces of both A and B
        return dfs(N, N);
    }
};
